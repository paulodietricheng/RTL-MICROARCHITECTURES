timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Engineer: Paulo Dietrich
// Create Date: 01/18/2026
// Design Name: Combinational Priority Selector
// Module Name: Priority_Select_Comb
// Description: Parameterized combinational priority selector
//////////////////////////////////////////////////////////////////////////////////
module Priority_Select_Low_Latency #(
    parameter int N = 8,
    parameter int DATA_W = 16
    )(
        input  logic clk,
        input  logic rst_n,
        input  logic [N-1:0] valid_in,
        input  logic [N-1:0][DATA_W-1:0] data_in,

        output logic valid_out,
        output logic [DATA_W-1:0] data_out,
        output logic [$clog2(N)-1:0] idx_out
    );

    localparam int IDX_W  = $clog2(N);
    localparam int STAGES = $clog2(N);

    // Stage arrays
    logic [0:STAGES][N-1:0] v;
    logic [0:STAGES][N-1:0][DATA_W-1:0] d;
    logic [0:STAGES][N-1:0][IDX_W-1:0] i;

    // Input Register
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            v[0] <= '0;
            d[0] <= '0;
            i[0] <= '0;
        end else begin
            for (int k = 0; k < N; k++) begin
                v[0][k] <= valid_in[k];
                d[0][k] <= data_in[k];
                i[0][k] <= k[IDX_W-1:0];
            end
        end
    end

    // Priority tree
    genvar s, k;
    generate
        for (s = 0; s < STAGES; s++) begin : GEN_TREE
            for (k = 0; k < (N >> s); k += 2) begin : GEN_NODE
                Selector_Module #(
                    .DATA_W(DATA_W),
                    .IDX_W (IDX_W)
                ) U_SEL (
                    .valid_a(v[s][k]),
                    .valid_b(v[s][k+1]),
                    .data_a(d[s][k]),
                    .data_b(d[s][k+1]),
                    .idx_a(i[s][k]),
                    .idx_b(i[s][k+1]),
                    .valid_w(v[s+1][k>>1]),
                    .data_w(d[s+1][k>>1]),
                    .idx_w(i[s+1][k>>1])
                );
            end
        end
    endgenerate

    // Output Register
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            valid_out <= 1'b0;
            data_out  <= '0;
            idx_out   <= '0;
        end else begin
            valid_out <= v[STAGES][0];
            data_out  <= d[STAGES][0];
            idx_out   <= i[STAGES][0];
        end
    end

endmodule
